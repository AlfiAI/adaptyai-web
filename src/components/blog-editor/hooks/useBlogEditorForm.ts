
import { useState, useEffect } from 'react';
import { useForm } from "react-hook-form";
import { useNavigate } from 'react-router-dom';
import { useToast } from '@/hooks/use-toast';
import { slugify } from '@/lib/utils';
import { getBlogRepository } from '@/lib/dataAccess/factory';
import { BlogPostData } from '@/lib/dataAccess/types';
import { BlogFormData, defaultBlogPost, AUTOSAVE_KEY } from '../types';
import { useBlogEditorContext } from '../context/BlogEditorContext';

export const useBlogEditorForm = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const { 
    setProgress, 
    completedSteps, 
    setCompletedSteps, 
    isSubmitting, 
    setIsSubmitting,
    setIsAutoSaving,
    activeStep, 
    setActiveStep
  } = useBlogEditorContext();

  // Initialize form with default values
  const methods = useForm<BlogFormData>({
    defaultValues: {
      ...defaultBlogPost,
      key_takeaways: [],
      faqs: [],
    },
  });

  const { watch, setValue, getValues, handleSubmit } = methods;

  // Watch for title changes to auto-generate slug
  const title = watch('title');
  useEffect(() => {
    if (title) {
      setValue('slug', slugify(title));
    }
  }, [title, setValue]);

  // Load autosaved data on mount
  useEffect(() => {
    const autosavedData = localStorage.getItem(AUTOSAVE_KEY);
    if (autosavedData) {
      try {
        const parsedData = JSON.parse(autosavedData);
        
        // Convert string dates back to Date objects
        if (parsedData.published_at) {
          parsedData.published_at = new Date(parsedData.published_at);
        }
        
        // Restore form data
        Object.keys(parsedData).forEach(key => {
          if (key !== 'coverImageFile') {
            setValue(key as any, parsedData[key]);
          }
        });

        toast({
          title: "Draft Restored",
          description: "Your previous draft has been loaded.",
        });
      } catch (error) {
        console.error('Error loading autosaved data:', error);
      }
    }
  }, [setValue, toast]);

  // Autosave every 60 seconds
  useEffect(() => {
    const autosaveInterval = setInterval(() => {
      saveToLocalStorage();
    }, 60000); // 60 seconds

    return () => clearInterval(autosaveInterval);
  }, []);

  // Calculate progress
  useEffect(() => {
    const steps = Object.values(completedSteps);
    const completedCount = steps.filter(Boolean).length;
    setProgress((completedCount / steps.length) * 100);
  }, [completedSteps, setProgress]);

  // Update completed steps based on form data
  useEffect(() => {
    const formData = getValues();
    
    // Fix: Use an explicit object instead of a function to update completedSteps
    const updatedSteps: Record<string, boolean> = {
      'step-1': !!(formData.title && formData.slug),
      'step-2': !!formData.cover_image_url,
      'step-3': !!(formData.key_takeaways && formData.key_takeaways.length > 0),
      'step-4': !!(formData.body && formData.body.length > 10),
      'step-5': true // FAQs are optional
    };
    
    setCompletedSteps(updatedSteps);
  }, [watch, getValues, setCompletedSteps]);

  const saveToLocalStorage = () => {
    try {
      setIsAutoSaving(true);
      const formData = getValues();
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(formData));
      setIsAutoSaving(false);
    } catch (error) {
      console.error('Error saving to local storage:', error);
      setIsAutoSaving(false);
    }
  };

  const onSaveDraft = () => {
    saveToLocalStorage();
    toast({
      title: "Draft Saved",
      description: "Your draft has been saved locally.",
    });
  };

  const processBlogContent = (formData: BlogFormData): BlogPostData => {
    let processedBody = formData.body || '';
    
    // Add key takeaways section if present
    if (formData.key_takeaways && formData.key_takeaways.length > 0) {
      const takeawaysSection = `## Key Takeaways\n${formData.key_takeaways.map(item => `- ${item}`).join('\n')}\n\n`;
      processedBody = takeawaysSection + processedBody;
    }
    
    // Add FAQs section if present
    if (formData.faqs && formData.faqs.length > 0) {
      const faqsSection = `\n\n## Frequently Asked Questions\n\n${formData.faqs.map(faq => 
        `### ${faq.question}\n${faq.answer}`
      ).join('\n\n')}`;
      processedBody = processedBody + faqsSection;
    }
    
    return {
      id: '', // Will be generated by Supabase
      title: formData.title || 'Untitled',
      slug: formData.slug || slugify(formData.title || 'untitled'),
      excerpt: formData.excerpt || '',
      body: processedBody,
      author: formData.author || 'Admin',
      tags: formData.tags || [],
      cover_image_url: formData.cover_image_url || '',
      featured: formData.featured || false,
      published_at: formData.published_at || new Date(),
    };
  };

  const onSubmit = async (formData: BlogFormData) => {
    try {
      setIsSubmitting(true);
      
      // Process the blog post data
      const blogPostData = processBlogContent(formData);
      
      // Save to Supabase
      const blogRepo = getBlogRepository();
      const postId = await blogRepo.create(blogPostData);
      
      if (!postId) {
        throw new Error("Failed to create blog post");
      }
      
      // Clear autosaved data
      localStorage.removeItem(AUTOSAVE_KEY);
      
      toast({
        title: "Success!",
        description: "Your blog post has been published.",
      });
      
      // Redirect to the newly created blog post
      navigate(`/blog/${blogPostData.slug}`);
      
    } catch (error) {
      console.error('Error publishing blog post:', error);
      toast({
        title: "Error",
        description: "Failed to publish blog post. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // Navigation functions
  const handleStepChange = (direction: 'prev' | 'next') => {
    const steps = ['step-1', 'step-2', 'step-3', 'step-4', 'step-5', 'review'];
    const currentIndex = steps.indexOf(activeStep);
    
    if (direction === 'prev' && currentIndex > 0) {
      setActiveStep(steps[currentIndex - 1]);
    } else if (direction === 'next' && currentIndex < steps.length - 1) {
      setActiveStep(steps[currentIndex + 1]);
    }
  };

  return {
    methods,
    handleSubmit,
    onSubmit,
    onSaveDraft,
    handleStepChange,
  };
};
